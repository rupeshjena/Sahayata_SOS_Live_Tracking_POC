<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SOS POC ‚Äî simulated moving victim (route updates fixed)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map { height:100%; margin:0; padding:0; }
    #topbar {
      position:absolute; left:8px; top:8px; z-index:1000;
      background:rgba(255,255,255,0.95); padding:8px; border-radius:6px;
      font-family:Arial; box-shadow:0 1px 4px rgba(0,0,0,0.2);
      display:flex; gap:8px; align-items:center;
    }
    #topbar button{ margin-left:8px; padding:6px 8px; }
    #status { font-size:14px; }
    .rescuer-div-icon {
      display:flex;
      align-items:center;
      justify-content:center;
      width:36px;
      height:36px;
      border-radius:50%;
      background: rgba(0,123,255,0.95);
      color: white;
      font-size:18px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
      border: 2px solid white;
    }
  </style>
</head>
<body>
  <div id="topbar" style="display:none;">
    <div>
      <div id="status">Initializing simulation...</div>
      <div id="hint" style="font-size:12px;color:#444">Hint: open over HTTPS for geolocation to work on mobile.</div>
    </div>
    <div style="margin-left:auto;">
      <button id="openNative">Open in Google Maps</button>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
/* CONFIG */
const SIMULATION_INTERVAL_MS = 10000; // 10s
const SIM_POINTS = [
  { name: 'Rasulgarh Chowk', lat: 20.295550, lng: 85.857514 },
  { name: 'Vani Vihar Chowk', lat: 20.302518, lng: 85.840945 },
  { name: 'Acharya Vihar Chowk', lat: 20.303630, lng: 85.800150 },
  { name: 'Jaydev Vihar Chowk', lat: 20.299727, lng: 85.817264 },
  { name: 'Nayapalli Chowk', lat: 20.289898, lng: 85.810219 },
  { name: 'CRP Square', lat: 20.286389, lng: 85.807222 },
  { name: 'Fire Station Square', lat: 20.279040, lng: 85.799265 },
  { name: 'Baramunda Square', lat: 20.277640, lng: 85.794852 }
];
const DEST_MOVE_THRESHOLD_M = 8;
const MIN_ROUTE_INTERVAL_MS = 3000;
/* END CONFIG */

const statusEl = document.getElementById('status');
const openNativeBtn = document.getElementById('openNative');
function dbg(msg){ console.log(msg); }
function setStatus(msg){ statusEl.innerText = msg; dbg('STATUS: ' + msg); }

/* Initialize map */
let map = L.map('map').setView([20.29555,85.857514], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

/* State */
let victimMarker = null;
let rescuerMarker = null;
let routeLine = null;
let currentIndex = 0;
let lastVictim = null; // previous victim location object {lat,lng,ts,name}
let rescuerPos = null;
let simTimer = null;
let lastRouteTime = 0;
let watchId = null;

/* Rescuer icon */
const rescuerEmoji = 'üèçÔ∏è'; // change to 'üöó' or 'üö∂' if desired
const rescuerIcon = L.divIcon({
  html: `<div class="rescuer-div-icon">${rescuerEmoji}</div>`,
  className: '',
  iconSize: [36,36],
  iconAnchor: [18,18]
});

/* Utility: distance in meters */
function distanceMeters(a,b){
  if(!a||!b) return Infinity;
  const R=6371000, toRad=v=>v*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lng-a.lng);
  const lat1=toRad(a.lat), lat2=toRad(b.lat);
  const sinDLat=Math.sin(dLat/2), sinDLon=Math.sin(dLon/2);
  const aa = sinDLat*sinDLat + sinDLon*sinDLon * Math.cos(lat1) * Math.cos(lat2);
  const c = 2*Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R * c;
}

/* Place victim (does NOT compute movement) */
function placeVictimMarker(p){
  if(!victimMarker){
    victimMarker = L.marker([p.lat, p.lng], { title: 'Victim' }).addTo(map);
  } else {
    victimMarker.setLatLng([p.lat, p.lng]);
  }
  victimMarker.bindPopup(`<b>Victim</b><br>${p.name || ''}`).openPopup();
}

/* Place rescuer */
function placeRescuer(p){
  if(!rescuerMarker){
    rescuerMarker = L.marker([p.lat, p.lng], { icon: rescuerIcon, title: 'You (rescuer)' }).addTo(map);
  } else {
    rescuerMarker.setLatLng([p.lat, p.lng]);
  }
}

/* Draw route with OSRM */
async function drawRoute(origin, dest){
  try {
    if(!origin || !dest) return;
    const now = Date.now();
    if(now - lastRouteTime < MIN_ROUTE_INTERVAL_MS){
      dbg('Route throttled');
      return;
    }
    lastRouteTime = now;
    const url = `https://router.project-osrm.org/route/v1/driving/${origin.lng},${origin.lat};${dest.lng},${dest.lat}?overview=full&geometries=geojson`;
    dbg('OSRM url: ' + url);
    const r = await fetch(url);
    if(!r.ok) { dbg('OSRM status ' + r.status); return; }
    const j = await r.json();
    if(!j.routes || !j.routes.length) { dbg('no OSRM routes'); return; }
    const coords = j.routes[0].geometry.coordinates;
    const latlngs = coords.map(c=>[c[1], c[0]]);
    if(routeLine) routeLine.setLatLngs(latlngs);
    else routeLine = L.polyline(latlngs, { weight:5, color:'#2a9df4' }).addTo(map);

    const bounds = L.latLngBounds(latlngs);
    if(victimMarker) bounds.extend(victimMarker.getLatLng());
    if(rescuerMarker) bounds.extend(rescuerMarker.getLatLng());
    map.fitBounds(bounds.pad(0.25));
    dbg('Route drawn, duration(s): ' + (j.routes[0].duration || 'n/a'));
  } catch (e) {
    dbg('drawRoute error: ' + e);
  }
}

/* Show first victim immediately */
(function showInitialVictim(){
  const p = SIM_POINTS[0];
  placeVictimMarker({lat:p.lat, lng:p.lng, name:p.name});
  lastVictim = { lat:p.lat, lng:p.lng, ts: Date.now(), name: p.name };
  map.setView([p.lat, p.lng], 14);
  currentIndex = 1;
  setStatus(`Victim: ${p.name} (${p.lat.toFixed(5)}, ${p.lng.toFixed(5)})`);
})();

/* Simulation step: compute prevVictim -> newVictim then place and decide route */
async function simulationStep(){
  const prev = lastVictim ? { lat: lastVictim.lat, lng: lastVictim.lng } : null;
  const p = SIM_POINTS[currentIndex];
  const newVictim = { lat: p.lat, lng: p.lng, ts: Date.now(), name: p.name };

  // update marker & lastVictim
  placeVictimMarker(newVictim);
  lastVictim = newVictim;

  // if rescuer known, compute movement from prev -> new and update route if needed
  if(rescuerPos){
    const moved = prev ? distanceMeters(prev, newVictim) : Infinity;
    dbg('Victim moved meters: ' + moved.toFixed(1));
    if(moved >= DEST_MOVE_THRESHOLD_M){
      await drawRoute(rescuerPos, newVictim);
    } else {
      dbg('Victim moved < threshold; not recalculating route');
    }
  } else {
    map.panTo([newVictim.lat, newVictim.lng]);
  }

  currentIndex = (currentIndex + 1) % SIM_POINTS.length;
}

/* Start simulation */
simTimer = setInterval(simulationStep, SIMULATION_INTERVAL_MS);

/* Geolocation logic: request once then watch */
async function ensureGeolocationRequested(){
  if(!('geolocation' in navigator)){
    setStatus('Geolocation not supported');
    return;
  }

  // permissions check (best-effort)
  try {
    if(navigator.permissions && navigator.permissions.query){
      const p = await navigator.permissions.query({ name: 'geolocation' });
      dbg('permission state: ' + p.state);
      if(p.state === 'denied'){
        setStatus('Location permission denied. Allow in site settings.');
        // still attempt watch (may not prompt)
      }
      p.onchange = ()=> dbg('permission changed: ' + p.state);
    }
  } catch(e){
    dbg('permissions check failed: ' + e);
  }

  // request a one-time position (may prompt)
  navigator.geolocation.getCurrentPosition(pos=>{
    rescuerPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    placeRescuer(rescuerPos);
    setStatus('Your location obtained; route origin set to your device.');
    // draw route immediately if victim exists
    if(lastVictim) drawRoute(rescuerPos, lastVictim);
    // start watch
    startWatchPosition();
  }, err=>{
    dbg('getCurrentPosition error: ' + JSON.stringify(err));
    if(err && err.code === 1) setStatus('Permission denied. Allow and reload.');
    else if(err && err.code === 2) setStatus('Position unavailable; waiting for fix.');
    else if(err && err.code === 3) setStatus('Timeout while getting location; watching for updates.');
    else setStatus('Geolocation error (see console).');
    // still start watch to catch future fixes
    startWatchPosition();
  }, { enableHighAccuracy:true, timeout:8000, maximumAge:0 });
}

function startWatchPosition(){
  if(!('geolocation' in navigator)) return;
  if(watchId) return;
  watchId = navigator.geolocation.watchPosition(pos=>{
    const prevRescuer = rescuerPos ? { lat: rescuerPos.lat, lng: rescuerPos.lng } : null;
    rescuerPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    placeRescuer(rescuerPos);
    dbg('watchPosition update: ' + rescuerPos.lat + ',' + rescuerPos.lng);
    // if victim present, update route (throttled)
    if(lastVictim){
      const now = Date.now();
      if(now - lastRouteTime >= MIN_ROUTE_INTERVAL_MS){
        lastRouteTime = now;
        drawRoute(rescuerPos, lastVictim);
      } else dbg('Route update throttled on rescuer move');
    }
  }, err=>{
    dbg('watchPosition error: ' + JSON.stringify(err));
  }, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
}

/* UI button */
openNativeBtn.addEventListener('click', ()=>{
  if(!lastVictim) return alert('No victim location yet');
  const url = `https://www.google.com/maps/dir/?api=1&destination=${lastVictim.lat},${lastVictim.lng}&travelmode=driving`;
  window.location.href = url;
});

/* Start geolocation attempts */
ensureGeolocationRequested();

/* Secure origin hint */
(function checkOrigin(){
  const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if(!(location.protocol === 'https:' || isLocal)){
    dbg('SECURITY: Page not served over HTTPS nor localhost. Geolocation may be blocked. Use GitHub Pages or localhost for testing.');
    setStatus('Serve via HTTPS (GitHub Pages) or use http://localhost for geolocation on mobile.');
  } else dbg('Secure origin ok.');
})();
  </script>
</body>
</html>

