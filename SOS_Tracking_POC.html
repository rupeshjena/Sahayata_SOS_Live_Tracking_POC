<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SOS POC â€” rescuer-centered live navigation (Google Maps)</title>

  <style>
    html,body,#map { height:100%; margin:0; padding:0; }

    /* small top-left status pill */
    #status {
      position: absolute;
      left: 8px;
      top: 8px;
      z-index: 1200;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: Arial, Helvetica, sans-serif;
      font-weight: 600;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      display: none;
    }

    /* heartbeat dot (shown when route is updating) */
    #status::before {
      content: "";
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      background-color: #d9534f;
      transform: scale(0.7);
      opacity: 0;
    }

    #status.updating::before {
      opacity: 1;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%   { transform: scale(0.7); opacity: 0.7; }
      50%  { transform: scale(1.1); opacity: 1;   }
      100% { transform: scale(0.7); opacity: 0.7; }
    }

    /* recenter button */
    #recenterBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1200;
      background: white;
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      font-family: Arial, sans-serif;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="status">Initializingâ€¦</div>
  <div id="map"></div>
  <div id="recenterBtn">â¦¿ Recenter</div>

  <!-- Google Maps JS API -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCxHxFiNlzq9TUjWiemfQpRXla7NODMJV0&libraries=places"></script>

  <script>
/*CREATED BY RUPESH - UPDATED: smooth snapping, adaptive icon size, smooth recenter */

/* ========== CONFIG ========== */
const SIMULATION_INTERVAL_MS = 10000;
const POLL_INTERVAL_MS       = 10000;
const SIM_POINTS = [
  { name:'Rasulgarh',     lat:20.295550, lng:85.857514 },
  { name:'Vani Vihar',    lat:20.302518, lng:85.840945 },
  { name:'Acharya Vihar', lat:20.303630, lng:85.800150 },
  { name:'Jaydev Vihar',  lat:20.299727, lng:85.817264 },
  { name:'Nayapalli',     lat:20.289898, lng:85.810219 },
  { name:'CRP',           lat:20.286389, lng:85.807222 },
  { name:'Fire Station',  lat:20.279040, lng:85.799265 },
  { name:'Baramunda',     lat:20.277640, lng:85.794852 }
];

const DEST_MOVE_THRESHOLD_M = 4;
const MIN_ROUTE_INTERVAL_MS = 2500;
const GPS_INTERPOLATION_MS = 800;

/* snapping interpolation duration (ms) */
const SNAP_DURATION_MS = 600;
/* recenter animation duration (ms) */
const RECENTER_DURATION_MS = 700;

/* adaptive icon scale mapping: zoom -> size (px) */
const ICON_SIZE_BY_ZOOM = {
  12: 36,
  13: 40,
  14: 44,
  15: 48,
  16: 52,
  17: 56,
  18: 60
};

const urlParams = new URLSearchParams(window.location.search);
const VICTIM_MOBILE = urlParams.get("mobile") || "8093831436";
const VICTIM_NAME   = urlParams.get("name")   || "Rupesh";

let USE_SERVER = true;
if (!VICTIM_MOBILE || VICTIM_MOBILE.trim() === "") {
    USE_SERVER = false;
}
const SOS_MOBILE_NO = VICTIM_MOBILE;
/* ============================== */

let map, directionsService, directionsRenderer;
let rescuerMarker = null, victimMarker = null;
let rescuerPos = null, lastVictim = null;
let simIndex = 0, simTimer = null, pollTimer = null;
let lastRouteTime = 0;
let victimInfoWindow = null;

const statusEl = document.getElementById('status');

/* NEW: status-related globals */
let latestDistanceText = "";
let latestDurationText = "";
let latestSpeedKmph    = null; // kept for future; hidden from UI per request
let lastRescuerTimeMs  = null;

/* Haversine */
function distanceMeters(a,b){
  if(!a||!b) return Infinity;
  const R = 6371000, toRad = v => v * Math.PI / 180;
  const dLat = toRad(b.lat - a.lat), dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const aa = Math.sin(dLat/2)**2 +
             Math.sin(dLon/2)**2 * Math.cos(lat1) * Math.cos(lat2);
  return 2 * R * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
}

/* Bearing helper */
function bearingDegrees(from, to) {
  if (!from || !to) return 0;
  const toRad = Math.PI / 180;
  const toDeg = 180 / Math.PI;

  const lat1 = from.lat * toRad;
  const lat2 = to.lat * toRad;
  const dLon = (to.lng - from.lng) * toRad;

  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

  let brng = Math.atan2(y, x) * toDeg;
  brng = (brng + 360) % 360;
  return brng;
}

/* Full navigation-style camera: follow rescuer with tilt + heading */
function updateNavigationCamera(newPos, heading) {
  if (!map || !newPos) return;

  try {
    // Center on rescuer
    // We'll animate center elsewhere when needed; here keep immediate center for responsiveness:
    map.setCenter({ lat: newPos.lat, lng: newPos.lng });

    // Rotate + tilt if supported (vector map)
    if (typeof map.setHeading === "function") {
      map.setHeading(heading || 0);
    }
    if (typeof map.setTilt === "function") {
      map.setTilt(45); // 3D effect like navigation
    }
  } catch (e) {
    // ignore any errors silently
  }
}

/* Smooth animate map centre + optional heading/tilt over duration */
function animateMapTo(targetCenter, targetHeading = null, duration = RECENTER_DURATION_MS) {
  if (!map) return;
  const start = map.getCenter();
  const startLat = start.lat(), startLng = start.lng();
  const endLat = targetCenter.lat, endLng = targetCenter.lng;
  const startHeading = (typeof map.getHeading === "function") ? map.getHeading() || 0 : 0;
  const endHeading = targetHeading == null ? startHeading : targetHeading;
  const startTilt = (typeof map.getTilt === "function") ? map.getTilt() || 0 : 0;
  const endTilt = 45;

  const steps = Math.max(8, Math.floor(duration / 16));
  let i = 0;
  function step() {
    i++;
    const t = i / steps;
    const lat = startLat + (endLat - startLat) * t;
    const lng = startLng + (endLng - startLng) * t;
    map.setCenter({ lat, lng });

    if (typeof map.setHeading === "function") {
      const heading = startHeading + (endHeading - startHeading) * t;
      map.setHeading(heading);
    }
    if (typeof map.setTilt === "function") {
      const tilt = startTilt + (endTilt - startTilt) * t;
      map.setTilt(tilt);
    }
    if (i < steps) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* Heartbeat class toggler */
function setRouteUpdating(isUpdating) {
  if (!statusEl) return;
  if (isUpdating) {
    statusEl.classList.add("updating");
  } else {
    statusEl.classList.remove("updating");
  }
}

/* Centralised status text builder */
function updateStatusLabel() {
  if (!statusEl) return;

  const parts = [`Live tracking: ${VICTIM_NAME} (${VICTIM_MOBILE})`];

  if (latestDistanceText) {
    parts.push(`Distance: ${latestDistanceText}`);
  }
  if (latestDurationText) {
    parts.push(`ETA: ${latestDurationText}`);
  }
  // speed intentionally hidden as requested; to show later uncomment:
  // if (latestSpeedKmph != null) parts.push(`Speed: ${latestSpeedKmph.toFixed(1)} km/h`);

  statusEl.textContent = parts.join(" â€” ");
}

/* ========== NEW: route path helpers ========== */

/* Get full path array (LatLng objects) from current directionsRenderer routes.
   Uses step.path for high fidelity when available. */
function getCurrentRoutePath() {
  try {
    const dir = directionsRenderer && directionsRenderer.getDirections && directionsRenderer.getDirections();
    if (!dir || !dir.routes || !dir.routes.length) return null;
    const route = dir.routes[0];

    let path = [];
    if (route.legs && route.legs.length) {
      route.legs.forEach(leg => {
        if (leg.steps && leg.steps.length) {
          leg.steps.forEach(step => {
            if (step.path && step.path.length) {
              step.path.forEach(p => path.push({ lat: p.lat(), lng: p.lng() }));
            }
          });
        }
      });
    }

    if (path.length > 0) return path;

    if (route.overview_path && route.overview_path.length) {
      return route.overview_path.map(p => ({ lat: p.lat(), lng: p.lng() }));
    }
    return null;
  } catch (e) {
    return null;
  }
}

/* Closest point on polyline (path: array of {lat,lng}) to target {lat,lng} */
function closestPointOnPath(target, path) {
  if (!target || !path || !path.length) return null;

  function toXY(p) { return { x: p.lng, y: p.lat }; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

  const T = toXY(target);
  let best = null;
  let bestDist = Infinity;

  for (let i=0;i<path.length-1;i++){
    const a = toXY(path[i]);
    const b = toXY(path[i+1]);
    const ab = { x: b.x - a.x, y: b.y - a.y };
    const at = { x: T.x - a.x, y: T.y - a.y };
    const abLen2 = dot(ab,ab);
    let t = 0;
    if (abLen2 > 0) {
      t = dot(at,ab) / abLen2;
      if (t < 0) t = 0;
      if (t > 1) t = 1;
    }
    const proj = { x: a.x + ab.x * t, y: a.y + ab.y * t };
    const d2 = dist2(proj, T);
    if (d2 < bestDist) {
      bestDist = d2;
      best = { lat: proj.y, lng: proj.x };
    }
  }

  if (!best && path.length) return { lat: path[0].lat, lng: path[0].lng };
  return best;
}

/* Smoothly move marker from current â†’ target (lat,lng) over duration */
function smoothMoveMarker(marker, target, duration = SNAP_DURATION_MS) {
  if (!marker) return;
  const start = marker.getPosition();
  if (!start) { marker.setPosition(target); return; }
  const startLat = start.lat(), startLng = start.lng();
  const endLat = target.lat, endLng = target.lng;
  const steps = Math.max(6, Math.floor(duration / 16));
  let i = 0;
  function step() {
    i++;
    const t = i / steps;
    const lat = startLat + (endLat - startLat) * t;
    const lng = startLng + (endLng - startLng) * t;
    marker.setPosition({ lat, lng });
    if (i < steps) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* Adaptive icon size according to map zoom */
function updateMarkerIconForZoom() {
  if (!map || !rescuerMarker) return;
  const z = Math.round(map.getZoom ? map.getZoom() : 15);
  // pick nearest defined zoom
  let size = 44;
  for (let k in ICON_SIZE_BY_ZOOM) {
    const zk = parseInt(k,10);
    if (z >= zk) size = ICON_SIZE_BY_ZOOM[zk];
  }
  const svg = encodeURIComponent(`
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
	  <circle cx="12" cy="12" r="11" fill="#1b73e8"/>
	  <path d="M12 4l6 14-6-3-6 3 6-14z"
			fill="#ffffff" stroke="#ffffff" stroke-width="0.6" stroke-linejoin="round"/>
	</svg>`);
  rescuerMarker.setIcon({
    url: `data:image/svg+xml;charset=utf-8,${svg}`,
    scaledSize: new google.maps.Size(size, size),
    anchor: new google.maps.Point(size/2, size/2)
  });
}

/* Try to snap the rescuer marker to the middle of the route path with smoothing.
   If no route available, animate normally to GPS. */
function placeRescuerOnRouteOrDirect(newPos) {
  const path = getCurrentRoutePath();
  if (path && path.length >= 2) {
    const cp = closestPointOnPath(newPos, path);
    if (cp) {
      if (!rescuerMarker) {
        placeRescuer(cp);
      } else {
        // smooth move to snapped point
        smoothMoveMarker(rescuerMarker, cp, SNAP_DURATION_MS);
        // update icon size for zoom (in case not yet set)
        updateMarkerIconForZoom();
      }
      return;
    }
  }

  // fallback: animate normally to the raw GPS point
  if (!rescuerMarker) {
    placeRescuer(newPos);
  } else {
    smoothMoveMarker(rescuerMarker, newPos, GPS_INTERPOLATION_MS);
  }
}

/* ================== INIT MAP ================== */
function initMap() {
  map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: SIM_POINTS[0].lat, lng: SIM_POINTS[0].lng },
    zoom: 15,
    maxZoom: 18,
    gestureHandling: 'greedy',
    tilt: 0,

    mapTypeControl: false,
    streetViewControl: false,
    fullscreenControl: false,
    zoomControl: false
  });

  directionsService = new google.maps.DirectionsService();
  directionsRenderer = new google.maps.DirectionsRenderer({
    map: map,
    suppressMarkers: true,
    preserveViewport: true
  });

  // adapt icon when user changes zoom (keeps marker scaled to road visually)
  map.addListener('zoom_changed', () => {
    updateMarkerIconForZoom();
  });

  statusEl.style.display = "block";

  if (USE_SERVER) {
    statusEl.textContent = "Connecting to serverâ€¦";
    startServerPolling();
  } else {
    placeVictim(SIM_POINTS[0]);
    statusEl.textContent = "Demo mode";
    startSimulation();
  }

  startRescuerGeolocation();
}

/* ================== VICTIM MARKER ================== */
function placeVictim(p){
  const pos = { lat: p.lat, lng: p.lng };

  const victimIcon = {
    url: "victim_sos_pin.SVG",
    scaledSize: new google.maps.Size(50, 50),
    anchor: new google.maps.Point(25, 50)
  };

  if(!victimMarker){
    victimMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: "Victim (SOS)",
      icon: victimIcon
    });

    victimInfoWindow = new google.maps.InfoWindow({
      content: `<div style="font-weight:600;font-size:14px">
                  ðŸš¨ SOS Victim<br>Name: ${VICTIM_NAME}<br>Mobile: ${VICTIM_MOBILE}
                </div>`
    });

    victimInfoWindow.open(map, victimMarker);
    victimMarker.addListener("click", () => victimInfoWindow.open(map, victimMarker));

  } else {
    victimMarker.setPosition(pos);
  }

  lastVictim = { lat: p.lat, lng: p.lng };
}

/* ================== RESCUER MARKER ================== */
function placeRescuer(p){
  const pos = { lat: p.lat, lng: p.lng };

  if(!rescuerMarker){
    const svg = encodeURIComponent(`
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
	  <circle cx="12" cy="12" r="11" fill="#1b73e8"/>
	  <path d="M12 4l6 14-6-3-6 3 6-14z"
			fill="#ffffff" stroke="#ffffff" stroke-width="0.6" stroke-linejoin="round"/>
	</svg>
	`);

    rescuerMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: "You (rescuer)",
      optimized: false,
      icon: {
        url: `data:image/svg+xml;charset=utf-8,${svg}`,
        scaledSize: new google.maps.Size(44,44),
        anchor: new google.maps.Point(22,22)
      }
    });

    // ensure size matches zoom immediately
    updateMarkerIconForZoom();

  } else {
    rescuerMarker.setPosition(pos);
  }
}

/* Smooth animation (used as fallback for non-route movement) */
function animateMarkerTo(marker, targetLatLng, durationMs = GPS_INTERPOLATION_MS){
  if(!marker){ placeRescuer(targetLatLng); return; }
  const start = marker.getPosition();
  const startLat = start.lat(), startLng = start.lng();
  const endLat = targetLatLng.lat, endLng = targetLatLng.lng;
  const steps = Math.max(6, Math.floor(durationMs / 50));
  let i = 0;
  const tick = () => {
    i++;
    const t = i / steps;
    const lat = startLat + (endLat - startLat) * t;
    const lng = startLng + (endLng - startLng) * t;
    marker.setPosition({ lat, lng });
    if(i < steps) requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
}

/* Directions (Distance + ETA + navigation-like rotation + heartbeat) */
function drawRoute(origin, dest){
  if(!origin || !dest) return;
  const now = Date.now();
  if(now - lastRouteTime < MIN_ROUTE_INTERVAL_MS) return;
  lastRouteTime = now;

  directionsService.route({
    origin,
    destination: dest,
    travelMode: google.maps.TravelMode.DRIVING,
    drivingOptions: { departureTime: new Date() }
  }, (result, status) => {
    if(status === google.maps.DirectionsStatus.OK){
      directionsRenderer.setDirections(result);

      // ===== Distance + ETA calculation =====
      const route = result.routes && result.routes[0];
      const leg   = route && route.legs && route.legs[0];

      if (leg) {
        const distanceText = leg.distance && leg.distance.text ? leg.distance.text : "";
        const durationText = leg.duration && leg.duration.text ? leg.duration.text : "";

        latestDistanceText = distanceText;
        latestDurationText = durationText;
        updateStatusLabel(); // keep label always populated
      }
      // =====================================

      // Rotate map like navigation towards victim (fallback/orientation)
      updateNavigationView();
    }

    // Stop heartbeat once route calculation finished (success or fail)
    setRouteUpdating(false);
  });
}

/* ================== SIMULATION ================== */
function startSimulation(){
  simIndex = 1;
  placeVictim(SIM_POINTS[0]);

  simTimer = setInterval(() => {
    const prev = lastVictim;
    const p = SIM_POINTS[simIndex];
    placeVictim(p);

    if(rescuerPos && distanceMeters(prev, p) >= DEST_MOVE_THRESHOLD_M){
      // victim moved in dummy mode -> show heartbeat and recalc route
      setRouteUpdating(true);
      drawRoute(rescuerPos, p);
    }

    simIndex = (simIndex + 1) % SIM_POINTS.length;
  }, SIMULATION_INTERVAL_MS);
}

/* ================== SERVER POLLING ================== */
function buildSoapBody(mobileNo){
  return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetSOSLocationDetails xmlns="http://tempuri.org/">
      <MobileNo></MobileNo>
      <SelfMobile>${mobileNo}</SelfMobile>
      <imieno></imieno>
      <mobiletype></mobiletype>
      <strToken></strToken>
      <strIpNo></strIpNo>
      <strLoginID></strLoginID>
    </GetSOSLocationDetails>
  </soap:Body>
</soap:Envelope>`;
}

async function fetchVictimFromServer(){
  const url  = "https://services-op.odisha.gov.in/Mobile_App/CitizenService.asmx";
  const action = "http://tempuri.org/GetSOSLocationDetails";

  const res = await fetch(url, {
    method:"POST",
    headers:{
      "Content-Type":"text/xml; charset=utf-8",
      "SOAPAction":action
    },
    body: buildSoapBody(SOS_MOBILE_NO)
  });

  const txt = await res.text();
  const xml = new DOMParser().parseFromString(txt,"text/xml");

  const lat = parseFloat(xml.getElementsByTagName("lattitude")[0]?.textContent);
  const lng = parseFloat(xml.getElementsByTagName("longitude")[0]?.textContent);

  return { lat, lng };
}

function startServerPolling(){
  const poll = async () => {
    try {
      const prev = lastVictim;
      const v = await fetchVictimFromServer();
      placeVictim(v);

      if(rescuerPos && distanceMeters(prev, v) >= DEST_MOVE_THRESHOLD_M){
        // victim moved from server -> show heartbeat and recalc route
        setRouteUpdating(true);
        drawRoute(rescuerPos, v);
      }

      // Status label is maintained by drawRoute + updateStatusLabel

    } catch(e){
      statusEl.textContent = "Error contacting SOS server.";
      setRouteUpdating(false);
    }
  };

  poll();
  pollTimer = setInterval(poll, POLL_INTERVAL_MS);
}

/* ================== RESCUER GEOLOCATION ================== */
function startRescuerGeolocation(){
  if(!navigator.geolocation) return;

  navigator.geolocation.getCurrentPosition(pos => {
    const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    rescuerPos = p;
    lastRescuerTimeMs = Date.now(); // initialise for speed calc
    placeRescuerOnRouteOrDirect(p);

    if(lastVictim) drawRoute(rescuerPos, lastVictim);
  }, err => {
    console.warn('getCurrentPosition error', err);
  }, { enableHighAccuracy: true, timeout:8000 });

  navigator.geolocation.watchPosition(pos => {
    const newPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    const now = Date.now();
    const prevPos = rescuerPos ? { lat: rescuerPos.lat, lng: rescuerPos.lng } : null;

    // Compute speed based on previous rescuerPos and timestamp (kept but not shown)
    if (rescuerPos && lastRescuerTimeMs != null) {
      const dtSec = (now - lastRescuerTimeMs) / 1000;
      const distM = distanceMeters(rescuerPos, newPos);
      if (dtSec > 0.5 && distM > 0.5) { // basic noise filter
        const speed = (distM / dtSec) * 3.6; // m/s â†’ km/h
        latestSpeedKmph = speed;
        // speed hidden currently; to show uncomment in updateStatusLabel
      }
    }

    lastRescuerTimeMs = now;

    // Place rescuer marker snapped to route if a route exists, otherwise smooth animate to GPS point
    placeRescuerOnRouteOrDirect(newPos);

    rescuerPos = newPos;

    // Full navigation-style camera: follow movement direction
    if (prevPos) {
      const headingMove = bearingDegrees(prevPos, newPos);
      updateNavigationCamera(newPos, headingMove);
    } else {
      // First fix: if victim exists, orient towards victim
      if (lastVictim) {
        const headingVictim = bearingDegrees(newPos, lastVictim);
        updateNavigationCamera(newPos, headingVictim);
      } else {
        updateNavigationCamera(newPos, 0);
      }
    }

    if(lastVictim) drawRoute(rescuerPos, lastVictim);

  }, err => {
    console.warn('watchPosition error', err);
  }, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
}

/* ================== RECENTER BUTTON ================== */
document.getElementById("recenterBtn").onclick = () => {
  if(rescuerPos){
    let heading = 0;
    if (lastVictim) {
      heading = bearingDegrees(rescuerPos, lastVictim);
    }
    // Smooth recenter (animate)
    animateMapTo({ lat: rescuerPos.lat, lng: rescuerPos.lng }, heading, RECENTER_DURATION_MS);
  } else {
    // fallback: immediate
    if (rescuerMarker && rescuerMarker.getPosition) {
      const p = rescuerMarker.getPosition();
      map.panTo(p);
    }
  }
};

/* Start */
initMap();

/*CREATED BY RUPESH*/
  </script>
</body>
</html>
