<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SOS POC â€” rescuer-centered live navigation (Google Maps)</title>

  <style>
    html,body,#map { height:100%; margin:0; padding:0; }

    /* small top-left status pill */
    #status {
      position: absolute;
      left: 8px;
      top: 8px;
      z-index: 1200;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: Arial, Helvetica, sans-serif;
      font-weight: 600;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      display: none;
    }

    /* heartbeat dot (shown when route is updating) */
    #status::before {
      content: "";
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      background-color: #d9534f;
      transform: scale(0.7);
      opacity: 0;
    }

    #status.updating::before {
      opacity: 1;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%   { transform: scale(0.7); opacity: 0.7; }
      50%  { transform: scale(1.1); opacity: 1;   }
      100% { transform: scale(0.7); opacity: 0.7; }
    }

    /* recenter button */
    #recenterBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1200;
      background: white;
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      font-family: Arial, sans-serif;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="status">Initializingâ€¦</div>
  <div id="map"></div>
  <div id="recenterBtn">â¦¿ Recenter</div>

  <!-- Google Maps JS API -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCxHxFiNlzq9TUjWiemfQpRXla7NODMJV0&libraries=places"></script>

  <script>
/*CREATED BY RUPESH*/

/* ========== CONFIG ========== */
const SIMULATION_INTERVAL_MS = 10000;
const POLL_INTERVAL_MS       = 10000;
const SIM_POINTS = [
  { name:'Rasulgarh',     lat:20.295550, lng:85.857514 },
  { name:'Vani Vihar',    lat:20.302518, lng:85.840945 },
  { name:'Acharya Vihar', lat:20.303630, lng:85.800150 },
  { name:'Jaydev Vihar',  lat:20.299727, lng:85.817264 },
  { name:'Nayapalli',     lat:20.289898, lng:85.810219 },
  { name:'CRP',           lat:20.286389, lng:85.807222 },
  { name:'Fire Station',  lat:20.279040, lng:85.799265 },
  { name:'Baramunda',     lat:20.277640, lng:85.794852 }
];

const DEST_MOVE_THRESHOLD_M = 4;
const MIN_ROUTE_INTERVAL_MS = 2500;
const GPS_INTERPOLATION_MS = 800;

const urlParams = new URLSearchParams(window.location.search);
const VICTIM_MOBILE = urlParams.get("mobile") || "8093831436";
const VICTIM_NAME   = urlParams.get("name")   || "Rupesh";

let USE_SERVER = true;
if (!VICTIM_MOBILE || VICTIM_MOBILE.trim() === "") {
    USE_SERVER = false;
}
const SOS_MOBILE_NO = VICTIM_MOBILE;
/* ============================== */

let map, directionsService, directionsRenderer;
let rescuerMarker = null, victimMarker = null;
let rescuerPos = null, lastVictim = null;
let simIndex = 0, simTimer = null, pollTimer = null;
let lastRouteTime = 0;
let victimInfoWindow = null;

const statusEl = document.getElementById('status');

/* NEW: status-related globals */
let latestDistanceText = "";
let latestDurationText = "";
let latestSpeedKmph    = null;
let lastRescuerTimeMs  = null;

/* Haversine */
function distanceMeters(a,b){
  if(!a||!b) return Infinity;
  const R = 6371000, toRad = v => v * Math.PI / 180;
  const dLat = toRad(b.lat - a.lat), dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const aa = Math.sin(dLat/2)**2 +
             Math.sin(dLon/2)**2 * Math.cos(lat1) * Math.cos(lat2);
  return 2 * R * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
}

/* Bearing helper */
function bearingDegrees(from, to) {
  if (!from || !to) return 0;
  const toRad = Math.PI / 180;
  const toDeg = 180 / Math.PI;

  const lat1 = from.lat * toRad;
  const lat2 = to.lat * toRad;
  const dLon = (to.lng - from.lng) * toRad;

  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

  let brng = Math.atan2(y, x) * toDeg;
  brng = (brng + 360) % 360;
  return brng;
}

/* Full navigation-style camera: follow rescuer with tilt + heading */
function updateNavigationCamera(newPos, heading) {
  if (!map || !newPos) return;

  try {
    // Center on rescuer
    map.setCenter({ lat: newPos.lat, lng: newPos.lng });

    // Rotate + tilt if supported (vector map)
    if (typeof map.setHeading === "function") {
      map.setHeading(heading || 0);
    }
    if (typeof map.setTilt === "function") {
      map.setTilt(45); // 3D effect like navigation
    }
  } catch (e) {
    // ignore any errors silently
  }
}

/* Rotate map view rescuer -> victim (used after route calc as fallback) */
function updateNavigationView() {
  if (!map || !rescuerPos || !lastVictim) return;

  const heading = bearingDegrees(rescuerPos, lastVictim);
  updateNavigationCamera(rescuerPos, heading);
}

/* Heartbeat class toggler */
function setRouteUpdating(isUpdating) {
  if (!statusEl) return;
  if (isUpdating) {
    statusEl.classList.add("updating");
  } else {
    statusEl.classList.remove("updating");
  }
}

/* Centralised status text builder */
function updateStatusLabel() {
  if (!statusEl) return;

  const parts = [`Live tracking: ${VICTIM_NAME} (${VICTIM_MOBILE})`];

  if (latestDistanceText) {
    parts.push(`Distance: ${latestDistanceText}`);
  }
  if (latestDurationText) {
    parts.push(`ETA: ${latestDurationText}`);
  }
  if (latestSpeedKmph != null) {
    parts.push(`Speed: ${latestSpeedKmph.toFixed(1)} km/h`);
  }

  statusEl.textContent = parts.join(" â€” ");
}

/* ================== INIT MAP ================== */
function initMap() {
  map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: SIM_POINTS[0].lat, lng: SIM_POINTS[0].lng },
    zoom: 15,
    maxZoom: 18,               // keep zoom reasonable to avoid visual distortions
    gestureHandling: 'greedy',
    tilt: 0,

    mapTypeControl: false,
    streetViewControl: false,
    fullscreenControl: false,
    zoomControl: false   // â›” hide zoom buttons
  });

  directionsService = new google.maps.DirectionsService();
  directionsRenderer = new google.maps.DirectionsRenderer({
    map: map,
    suppressMarkers: true,
    preserveViewport: true
  });

  statusEl.style.display = "block";

  if (USE_SERVER) {
    statusEl.textContent = "Connecting to serverâ€¦";
    startServerPolling();
  } else {
    placeVictim(SIM_POINTS[0]);
    statusEl.textContent = "Demo mode";
    startSimulation();
  }

  startRescuerGeolocation();
}

/* ================== VICTIM MARKER ================== */
function placeVictim(p){
  const pos = { lat: p.lat, lng: p.lng };

  const victimIcon = {
    url: "victim_sos_pin.SVG",
    scaledSize: new google.maps.Size(50, 50),
    anchor: new google.maps.Point(25, 50)
  };

  if(!victimMarker){
    victimMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: "Victim (SOS)",
      icon: victimIcon
    });

    victimInfoWindow = new google.maps.InfoWindow({
      content: `<div style="font-weight:600;font-size:14px">
                  ðŸš¨ SOS Victim<br>Name: ${VICTIM_NAME}<br>Mobile: ${VICTIM_MOBILE}
                </div>`
    });

    victimInfoWindow.open(map, victimMarker);
    victimMarker.addListener("click", () => victimInfoWindow.open(map, victimMarker));

  } else {
    victimMarker.setPosition(pos);
  }

  lastVictim = { lat: p.lat, lng: p.lng };
}

/* ================== RESCUER MARKER ================== */
function placeRescuer(p){
  const pos = { lat: p.lat, lng: p.lng };

  if(!rescuerMarker){
    /* MAN ICON SVG */
    const svg = encodeURIComponent(`
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
	  <circle cx="12" cy="12" r="11" fill="#1b73e8"/>
	  <path d="M12 4l6 14-6-3-6 3 6-14z"
			fill="#ffffff"
			stroke="#ffffff"
			stroke-width="0.6"
			stroke-linejoin="round"/>
	</svg>
	`);

    rescuerMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: "You (rescuer)",
      icon: {
        url: `data:image/svg+xml;charset=utf-8,${svg}`,
        scaledSize: new google.maps.Size(40,40),
        anchor: new google.maps.Point(25,25)
      }
    });

  } else {
    rescuerMarker.setPosition(pos);
  }
}

/* Smooth animation */
function animateMarkerTo(marker, targetLatLng, durationMs = GPS_INTERPOLATION_MS){
  if(!marker){ placeRescuer(targetLatLng); return; }

  const start = marker.getPosition();
  const steps = Math.max(6, Math.floor(durationMs / 50));
  let i = 0;

  function step(){
    i++;
    const t = i/steps;
    const lat = start.lat() + (targetLatLng.lat - start.lat()) * t;
    const lng = start.lng() + (targetLatLng.lng - start.lng()) * t;
    marker.setPosition({lat,lng});
    if(i < steps) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* Directions (Distance + ETA + navigation-like rotation + heartbeat) */
function drawRoute(origin, dest){
  if(!origin || !dest) return;
  const now = Date.now();
  if(now - lastRouteTime < MIN_ROUTE_INTERVAL_MS) return;
  lastRouteTime = now;

  directionsService.route({
    origin,
    destination: dest,
    travelMode: google.maps.TravelMode.DRIVING,
    drivingOptions: { departureTime: new Date() }
  }, (result, status) => {
    if(status === google.maps.DirectionsStatus.OK){
      directionsRenderer.setDirections(result);

      // ===== Distance + ETA calculation =====
      const route = result.routes && result.routes[0];
      const leg   = route && route.legs && route.legs[0];

      if (leg) {
        const distanceText = leg.distance && leg.distance.text ? leg.distance.text : "";
        const durationText = leg.duration && leg.duration.text ? leg.duration.text : "";

        latestDistanceText = distanceText;
        latestDurationText = durationText;
        updateStatusLabel(); // keep label always populated
      }
      // =====================================

      // Rotate map like navigation towards victim (fallback/orientation)
      updateNavigationView();
    }

    // Stop heartbeat once route calculation finished (success or fail)
    setRouteUpdating(false);
  });
}

/* ================== SIMULATION ================== */
function startSimulation(){
  simIndex = 1;
  placeVictim(SIM_POINTS[0]);

  simTimer = setInterval(() => {
    const prev = lastVictim;
    const p = SIM_POINTS[simIndex];
    placeVictim(p);

    if(rescuerPos && distanceMeters(prev, p) >= DEST_MOVE_THRESHOLD_M){
      // victim moved in dummy mode -> show heartbeat and recalc route
      setRouteUpdating(true);
      drawRoute(rescuerPos, p);
    }

    simIndex = (simIndex + 1) % SIM_POINTS.length;
  }, SIMULATION_INTERVAL_MS);
}

/* ================== SERVER POLLING ================== */
function buildSoapBody(mobileNo){
  return `<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetSOSLocationDetails xmlns="http://tempuri.org/">
      <MobileNo></MobileNo>
      <SelfMobile>${mobileNo}</SelfMobile>
      <imieno></imieno>
      <mobiletype></mobiletype>
      <strToken></strToken>
      <strIpNo></strIpNo>
      <strLoginID></strLoginID>
    </GetSOSLocationDetails>
  </soap:Body>
</soap:Envelope>`;
}

async function fetchVictimFromServer(){
  const url  = "https://services-op.odisha.gov.in/Mobile_App/CitizenService.asmx";
  const action = "http://tempuri.org/GetSOSLocationDetails";

  const res = await fetch(url, {
    method:"POST",
    headers:{
      "Content-Type":"text/xml; charset=utf-8",
      "SOAPAction":action
    },
    body: buildSoapBody(SOS_MOBILE_NO)
  });

  const txt = await res.text();
  const xml = new DOMParser().parseFromString(txt,"text/xml");

  const lat = parseFloat(xml.getElementsByTagName("lattitude")[0]?.textContent);
  const lng = parseFloat(xml.getElementsByTagName("longitude")[0]?.textContent);

  return { lat, lng };
}

function startServerPolling(){
  const poll = async () => {
    try {
      const prev = lastVictim;
      const v = await fetchVictimFromServer();
      placeVictim(v);

      if(rescuerPos && distanceMeters(prev, v) >= DEST_MOVE_THRESHOLD_M){
        // victim moved from server -> show heartbeat and recalc route
        setRouteUpdating(true);
        drawRoute(rescuerPos, v);
      }

      // Status label is maintained by drawRoute + updateStatusLabel

    } catch(e){
      statusEl.textContent = "Error contacting SOS server.";
      setRouteUpdating(false);
    }
  };

  poll();
  pollTimer = setInterval(poll, POLL_INTERVAL_MS);
}

/* ================== RESCUER GEOLOCATION ================== */
function startRescuerGeolocation(){
  if(!navigator.geolocation) return;

  navigator.geolocation.getCurrentPosition(pos => {
    const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    rescuerPos = p;
    lastRescuerTimeMs = Date.now(); // initialise for speed calc
    placeRescuer(p);

    if(lastVictim) drawRoute(rescuerPos, lastVictim);
  });

  navigator.geolocation.watchPosition(pos => {
    const newPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    const now = Date.now();
    const prevPos = rescuerPos ? { lat: rescuerPos.lat, lng: rescuerPos.lng } : null;

    // Compute speed based on previous rescuerPos and timestamp
    if (rescuerPos && lastRescuerTimeMs != null) {
      const dtSec = (now - lastRescuerTimeMs) / 1000;
      const distM = distanceMeters(rescuerPos, newPos);
      if (dtSec > 0.5 && distM > 0.5) { // basic noise filter
        const speed = (distM / dtSec) * 3.6; // m/s â†’ km/h
        latestSpeedKmph = speed;
        updateStatusLabel();
      }
    }

    lastRescuerTimeMs = now;

    if(rescuerMarker){
      animateMarkerTo(rescuerMarker, newPos);
    } else {
      placeRescuer(newPos);
    }

    rescuerPos = newPos;

    // Full navigation-style camera: follow movement direction
    if (prevPos) {
      const headingMove = bearingDegrees(prevPos, newPos);
      updateNavigationCamera(newPos, headingMove);
    } else {
      // First fix: if victim exists, orient towards victim
      if (lastVictim) {
        const headingVictim = bearingDegrees(newPos, lastVictim);
        updateNavigationCamera(newPos, headingVictim);
      } else {
        updateNavigationCamera(newPos, 0);
      }
    }

    if(lastVictim) drawRoute(rescuerPos, lastVictim);

  }, null, { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
}

/* ================== RECENTER BUTTON ================== */
document.getElementById("recenterBtn").onclick = () => {
  if(rescuerPos){
    // In full nav mode, recenter also re-applies camera tilt/heading towards victim if available
    let heading = 0;
    if (lastVictim) {
      heading = bearingDegrees(rescuerPos, lastVictim);
    }
    updateNavigationCamera(rescuerPos, heading);
  }
};

/* Start */
initMap();

/*CREATED BY RUPESH*/
  </script>
</body>
</html>

