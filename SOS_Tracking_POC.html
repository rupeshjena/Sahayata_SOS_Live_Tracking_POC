<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SOS POC ‚Äî rescuer-centered live navigation (Google Maps)</title>
  <style>
    html,body,#map { height:100%; margin:0; padding:0; }
    /* small top-left status pill (optional, remove if you want zero UI) */
    #status {
      position: absolute;
      left: 8px;
      top: 8px;
      z-index: 1200;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: Arial, Helvetica, sans-serif;
      font-weight: 600;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      display: none; /* hidden by default (remove 'display:none' to show) */
    }
  </style>
</head>
<body>
  <div id="status">Initializing‚Ä¶</div>
  <div id="map"></div>

  <!-- Replace the key below with your Google Maps JS API key -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBVdTJ6ySwKgB4NnNQ67yelSg9vCFPjSAI&libraries=places"></script>
  <script>
/* ========== CONFIG ========== */
const SIMULATION_INTERVAL_MS = 10000;   // victim move interval during demo
const SIM_POINTS = [
  { name:'Rasulgarh', lat:20.295550, lng:85.857514 },
  { name:'Vani Vihar', lat:20.302518, lng:85.840945 },
  { name:'Acharya Vihar', lat:20.303630, lng:85.800150 },
  { name:'Jaydev Vihar', lat:20.299727, lng:85.817264 },
  { name:'Nayapalli', lat:20.289898, lng:85.810219 },
  { name:'CRP', lat:20.286389, lng:85.807222 },
  { name:'Fire Station', lat:20.279040, lng:85.799265 },
  { name:'Baramunda', lat:20.277640, lng:85.794852 }
];
const DEST_MOVE_THRESHOLD_M = 4;   // when victim moves this many meters, recalc route
const MIN_ROUTE_INTERVAL_MS = 2500; // throttle route requests
const GPS_INTERPOLATION_MS = 800;   // smoothing of rescuer marker between GPS fixes
/* ============================== */

let map, directionsService, directionsRenderer;
let rescuerMarker = null, victimMarker = null;
let rescuerPos = null, lastVictim = null;
let simIndex = 0, simTimer = null;
let lastRouteTime = 0;
const statusEl = document.getElementById('status');

/* Small helper: haversine distance in meters */
function distanceMeters(a,b){
  if(!a||!b) return Infinity;
  const R = 6371000, toRad = v => v * Math.PI / 180;
  const dLat = toRad(b.lat - a.lat), dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const sinDLat = Math.sin(dLat/2), sinDLon = Math.sin(dLon/2);
  const aa = sinDLat*sinDLat + sinDLon*sinDLon * Math.cos(lat1) * Math.cos(lat2);
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R * c;
}

/* Initialize Google Map and Directions */
function initMap() {
  map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: SIM_POINTS[0].lat, lng: SIM_POINTS[0].lng },
    zoom: 15,
    gestureHandling: 'greedy', // allow user gestures
    tilt: 0,
    mapTypeControl: false,
    streetViewControl: false,
    fullscreenControl: false
  });

  directionsService = new google.maps.DirectionsService();
  directionsRenderer = new google.maps.DirectionsRenderer({
    map: map,
    suppressMarkers: true,
    preserveViewport: true // IMPORTANT: do not auto-fit map to route; we keep rescuer centered
  });

  // place initial victim marker (simulation)
  const p = SIM_POINTS[0];
  placeVictim(p);

  // start victim simulation loop (replace this with your API polling when ready)
  startSimulation();

  // start rescuer geolocation
  startRescuerGeolocation();
}

/* Place or update victim marker */
function placeVictim(p){
  const pos = { lat: p.lat, lng: p.lng };

  const victimIcon = {
    url: "victim_sos_pin.svg",    // your file in project root
    scaledSize: new google.maps.Size(50, 50),  // adjust size
    anchor: new google.maps.Point(25, 50)      // bottom center
  };

  if(!victimMarker){
    victimMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: "Victim (SOS)",
      icon: victimIcon
    });
  } else {
    victimMarker.setPosition(pos);
  }

  lastVictim = { lat: p.lat, lng: p.lng, name: p.name || '' };
}

/* Place or update rescuer marker (bike icon via SVG path) */
function placeRescuer(p){
  const pos = { lat: p.lat, lng: p.lng };
  if(!rescuerMarker){
    // simple bike/person marker ‚Äî using a small SVG so it rotates nicely if you add rotation later
    const svg = encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="11" fill="#0b63d6"/>
        <text x="50%" y="53%" font-size="14" text-anchor="middle" fill="white" font-family="sans-serif">üèçÔ∏è</text>
      </svg>`);
    rescuerMarker = new google.maps.Marker({
      position: pos,
      map: map,
      title: 'You (rescuer)',
      icon: {
        url: `data:image/svg+xml;charset=utf-8,${svg}`,
        scaledSize: new google.maps.Size(36,36),
        anchor: new google.maps.Point(18,18)
      }
    });
  } else {
    rescuerMarker.setPosition(pos);
  }
}

/* Smoothly interpolate marker from current -> target over durationMs */
function animateMarkerTo(marker, targetLatLng, durationMs = GPS_INTERPOLATION_MS) {
  if(!marker) { placeRescuer(targetLatLng); return; }
  const start = marker.getPosition();
  const startLat = start.lat(), startLng = start.lng();
  const endLat = targetLatLng.lat, endLng = targetLatLng.lng;
  const steps = Math.max(6, Math.floor(durationMs / 50));
  let i = 0;
  const tick = () => {
    i++;
    const t = i / steps;
    const lat = startLat + (endLat - startLat) * t;
    const lng = startLng + (endLng - startLng) * t;
    marker.setPosition({ lat, lng });
    if(i < steps) {
      requestAnimationFrame(tick);
    }
  };
  requestAnimationFrame(tick);
}

/* Draw route using Google Directions API; we set preserveViewport=true so renderer won't change camera */
function drawRoute(origin, dest) {
  if(!origin || !dest) return;
  const now = Date.now();
  if(now - lastRouteTime < MIN_ROUTE_INTERVAL_MS) return;
  lastRouteTime = now;

  const request = {
    origin: { lat: origin.lat, lng: origin.lng },
    destination: { lat: dest.lat, lng: dest.lng },
    travelMode: google.maps.TravelMode.DRIVING,
    drivingOptions: { departureTime: new Date() } // use current time for ETA
  };

  directionsService.route(request, (result, status) => {
    if(status === google.maps.DirectionsStatus.OK && result) {
      directionsRenderer.setDirections(result);
      // we suppressed default markers; show our markers remain
    } else {
      // fallback: you may handle errors or fallback to polyline from route geometry if needed
      console.warn('Directions request failed: ', status);
    }
  });
}

/* Simulation loop (victim moves through SIM_POINTS). Replace this with API polling later. */
function startSimulation() {
  simIndex = 1;
  placeVictim(SIM_POINTS[0]);
  simTimer = setInterval(async () => {
    const prev = lastVictim ? { lat: lastVictim.lat, lng: lastVictim.lng } : null;
    const p = SIM_POINTS[simIndex];
    const newVictim = { lat: p.lat, lng: p.lng, name: p.name };
    placeVictim(newVictim);

    if(rescuerPos){
      const moved = prev ? distanceMeters(prev, newVictim) : Infinity;
      if(moved >= DEST_MOVE_THRESHOLD_M){
        drawRoute(rescuerPos, newVictim);
      }
    }

    simIndex = (simIndex + 1) % SIM_POINTS.length;
  }, SIMULATION_INTERVAL_MS);
}

/* Start geolocation for rescuer: get one shot + watch, interpolate marker, always pan to rescuer */
function startRescuerGeolocation(){
  if(!('geolocation' in navigator)) {
    console.warn('Geolocation unsupported');
    return;
  }

  // get initial position
  navigator.geolocation.getCurrentPosition(pos => {
    const p = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    rescuerPos = p;
    placeRescuer(p);
    // initially draw route if victim exists
    if(lastVictim) drawRoute(rescuerPos, lastVictim);
    // center on rescuer
    map.setCenter({ lat: rescuerPos.lat, lng: rescuerPos.lng });
  }, err => {
    console.warn('getCurrentPosition error', err);
  }, { enableHighAccuracy: true, timeout:8000 });

  // watch position
  navigator.geolocation.watchPosition(pos => {
    const newPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    // smooth visual move
    if(rescuerMarker){
      animateMarkerTo(rescuerMarker, newPos, GPS_INTERPOLATION_MS);
    } else {
      placeRescuer(newPos);
    }
    rescuerPos = newPos;

    // ALWAYS pan/center map to rescuer -- keeps rescuer focal
    map.panTo({ lat: newPos.lat, lng: newPos.lng }, { duration: 0.3 });

    // Recalculate route to latest victim when needed (throttled inside drawRoute)
    if(lastVictim) drawRoute(rescuerPos, lastVictim);
  }, err => {
    console.warn('watchPosition error', err);
  }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 });
}

/* --- Start everything after API loads --- */
function start() {
  initMap();
}

/* Kick off */
start();

/* ================= Switching to real API (notes) =================
When your SOAP/REST API is ready, replace startSimulation() and the simTimer with a polling function:
- Poll your backend endpoint (CORS must be allowed) that returns JSON { lat:number, lng:number, ts?:string }.
- On each response call placeVictim(resp) and drawRoute(rescuerPos, resp).
Example (pseudo):
  async function pollVictim(){
    const r = await fetch('https://yourserver/api/sos/latest?id=xxxx');
    const j = await r.json(); // {lat,lng}
    placeVictim(j);
    if(rescuerPos) drawRoute(rescuerPos, j);
  }
Set interval as required (3s for your system).
================================================================== */

  </script>
</body>
</html>


